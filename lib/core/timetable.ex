defmodule Core.Timetable do
  @moduledoc """
  Timetable is just a formatted representation
  of the results generated by the GA.
  """

  alias Core.Todo

  @doc """
  Synchronizes the result of the GA with the todos
  """
  def from_schedule(timetable, todos, time_streaks) do
    timetable
    |> Enum.with_index()
    |> Enum.map(fn {streak_todos, index} ->
      {todos, _} =
        case Enum.at(time_streaks, index) do
          nil ->
            raise "Time streak does not exist given the index #{index}"

          {from, _to} ->
            Enum.reduce(streak_todos, {[], 0}, fn
              todo_id, {curr_streak_todos, offset} ->
                duration_offset = Timex.Duration.from_minutes(offset)
                todo = Todo.get_todo(todos, todo_id)
                duration = Timex.Duration.from_minutes(todo.weight)

                from = Timex.add(from, duration_offset)
                to = Timex.add(from, duration)

                case Todo.update_todo(todos, todo_id, %{from: from, to: to}) do
                  {:error, _} ->
                    raise "Something went wrong in updating"

                  {:ok, new_todo} ->
                    new_curr_streak_todos = curr_streak_todos ++ [new_todo]
                    {new_curr_streak_todos, offset + Timex.diff(to, from, :minutes)}
                end
            end)
        end

      todos
    end)
    |> List.flatten()
  end

  @doc """
  Prints out a readable timetable for humans.
  """
  def print(timetable, todos, time_streaks) do
    IO.puts("""
    \nNOTE: Do not print in production. Only use `Timetable.print(...)`
    for debugging purposes.
    """)

    timetable
    |> from_schedule(todos, time_streaks)
    |> Scribe.print(data: [:id, :name, :priority, :weight, :from, :to])
  end

  def get_streak_capacity(streak, todos) do
    Enum.map(streak, fn todo_id ->
      todo = Todo.get_todo(todos, todo_id)

      todo.weight
    end)
    |> Enum.sum()
  end

  def get_timetable_capacity(timetable, todos) do
    Enum.map(timetable, fn streak ->
      get_streak_capacity(streak, todos)
    end)
  end

  def shuffle(timetable) do
    Enum.map(timetable, fn streak ->
      Enum.shuffle(streak)
    end)
  end

  @doc """
  This just sorts the tasks in the streak based on priority. This does not
  affect the fitness score in any way.
  """
  def sort_todos(timetable, todos) do
    Enum.map(timetable, fn streak ->
      Enum.sort_by(
        streak,
        fn todo_id ->
          %{priority: p} = Todo.get_todo(todos, todo_id)

          p
        end,
        :desc
      )
    end)
  end
end
